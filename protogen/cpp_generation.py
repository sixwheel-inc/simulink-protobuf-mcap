from dense_log_codegen.order_busses import (
    order_busses_by_dependency,
    NOT_ALLOWED_U,
    NOT_ALLOWED_I,
    NOT_ALLOWED_OTHER,
)


def get_proto_field_name(name):
    # proto_field_name = name.replace("_", "")
    proto_field_name = name.lower()
    print(f"{name} -> {proto_field_name}")
    return proto_field_name


BUS_FIELD = "  {type} {name};\n"
BUS_MESSAGE_FIELD = "  Bus_{type} {name};\n"
BUS_STRUCT = """
typedef struct _Bus_{bus_name} {{
{fields}
}} Bus_{bus_name};
"""
BUS_HEADER = """
// AUTOGENERATED FILE, DO NOT EDIT //
#ifndef _BUS_H_
#define _BUS_H_

#include <stdint.h>
#include <stdbool.h>

{messages}

#endif
"""


def generate_bus_h(mat_structure):
    ordered_busses, _ = order_busses_by_dependency(
        mat_structure, root_bus
    )

    messages = []
    for bus_name in ordered_busses:
        bus = mat_structure[bus_name]
        fields = []
        for i, (name, type_) in enumerate(bus.items()):
            if type_ == "boolean":
                type_ = "bool"
            elif type_ == "single":
                type_ = "float"
            elif type_ in set(
                [
                    "uint8",
                    "uint16",
                    "uint32",
                    "uint64",
                    "int8",
                    "int16",
                    "int32",
                    "int64",
                ]
            ):
                type_ = type_ + "_t"
            elif type_ in NOT_ALLOWED_OTHER:
                raise NotImplementedError("ERROR: {} is not supported!".format(type_))

            if type_ in mat_structure:
                fields.append(BUS_MESSAGE_FIELD.format(name=name, type=type_))
            else:
                fields.append(BUS_FIELD.format(name=name, type=type_))
        messages.append(BUS_STRUCT.format(bus_name=bus_name, fields="".join(fields)))
    return BUS_HEADER.format(messages="".join(messages))


INCLUDE = """
#include "{include}"
"""

BUS_TO_PROTO_DEF = """
::{bus_name} bus_to_proto_{bus_name}(const revoy::{bus_name} &bus);
"""

BUS_TO_PROTO_H = """
#pragma once

// AUTOGENERATED FILE, DO NOT EDIT //

{includes}

{defs}


"""


def generate_bus_to_proto_h(mat_structure, includes):
    defs = []
    for bus_name, bus in mat_structure.items():
        defs.append(BUS_TO_PROTO_DEF.format(bus_name=bus_name, bus_name_proto=bus_name))

    incls = []
    for include in includes:
        incls.append(INCLUDE.format(include=include))

    return BUS_TO_PROTO_H.format(includes="\n".join(incls), defs="\n".join(defs))


BUS_TO_PROTO_MESSAGE = """
  {{
     ::{bus_name} proto = bus_to_proto_{bus_name}(bus.{bus_name});
     *top.mutable_{proto_field_name}() = std::move(proto);
  }}
"""

BUS_TO_PROTO_UINT = (
    "  top.set_{proto_field_name}(static_cast<uint32_t>(bus.{pre}{name}));"
)
BUS_TO_PROTO_INT = (
    "  top.set_{proto_field_name}(static_cast<int32_t>(bus.{pre}{name}));"
)
BUS_TO_PROTO_ANY = "  top.set_{proto_field_name}(bus.{pre}{name});"
BUS_TO_PROTO_IMPL = """
::{bus_name} bus_to_proto_{bus_name}(const revoy::{bus_name} &bus) {{

  ::{bus_name} top;

  {fields}

  return top;

}}

"""
BUS_TO_PROTO_C = """
// AUTOGENERATED FILE, DO NOT EDIT //
#include "{busses_to_proto_h}"
{impls}
"""


def generate_bus_to_proto_c(mat_structure, busses_to_proto_h):
    impls = []
    for bus_name, bus in mat_structure.items():
        fields = []

        pre = ""
        if bus_name.endswith("Inputs"):
            pre = "In_"
        elif bus_name.endswith("Outputs"):
            pre = "Out_"

        for i, (name, type_) in enumerate(bus.items()):

            proto_field_name = get_proto_field_name(name)
            if type_ in NOT_ALLOWED_U:
                fields.append(
                    BUS_TO_PROTO_UINT.format(
                        proto_field_name=proto_field_name, name=name, pre=pre
                    )
                )
            elif type_ in NOT_ALLOWED_I:
                fields.append(
                    BUS_TO_PROTO_INT.format(
                        proto_field_name=proto_field_name, name=name, pre=pre
                    )
                )
            elif type_ in NOT_ALLOWED_OTHER:
                raise NotImplementedError("ERROR: {} is not supported!".format(type_))
            elif type_ in mat_structure:
                fields.append(
                    BUS_TO_PROTO_MESSAGE.format(
                        bus_name=name,
                        proto_field_name=proto_field_name,
                    )
                )
            else:
                fields.append(
                    BUS_TO_PROTO_ANY.format(
                        proto_field_name=proto_field_name, name=name, pre=pre
                    )
                )
        impls.append(
            BUS_TO_PROTO_IMPL.format(bus_name=bus_name, fields="\n".join(fields))
        )
    return BUS_TO_PROTO_C.format(
        busses_to_proto_h=busses_to_proto_h, impls="\n".join(impls)
    )


PROTO_TO_BUS_FUNCTION_DEF = """
Bus_{bus_name} proto_to_bus_{bus_name}(const ::{bus_name} &proto);
"""

PROTO_TO_BUS_H = """
#pragma once

// AUTOGENERATED FILE, DO NOT EDIT //

#include "{pb_h}"
#include "{bus_h}"

{functions}
"""


def generate_proto_to_bus_h(mat_structure, pb_h, bus_h):
    _, ordered_busses = order_busses_by_dependency(
        mat_structure, root_bus
    )
    functions = []
    for bus_name, bus in ordered_busses.items():
        for i, (name, type_) in enumerate(bus.items()):
            if type_ == "boolean":
                type_ = "bool"
            elif type_ == "single":
                type_ = "float"
            elif type_ in NOT_ALLOWED_OTHER:
                raise NotImplementedError("ERROR: {} is not supported!".format(type_))
            elif type_ in set(
                [
                    "uint8",
                    "uint16",
                    "uint32",
                    "uint64",
                    "int8",
                    "int16",
                    "int32",
                    "int64",
                ]
            ):
                type_ = type_ + "_t"

        functions.append(PROTO_TO_BUS_FUNCTION_DEF.format(bus_name=bus_name))

    return PROTO_TO_BUS_H.format(pb_h=pb_h, bus_h=bus_h, functions="".join(functions))


PROTO_TO_BUS_ANY = "  bus.{field_name} = proto.{proto_field_name}();\n"
PROTO_TO_BUS_CONVERT = (
    "  bus.{field_name} = proto_to_bus_{field_name}(proto.{proto_field_name}());\n"
)

PROTO_TO_BUS_IMPL = """
Bus_{bus_name} proto_to_bus_{bus_name}(const ::{bus_name} &proto) {{
Bus_{bus_name} bus;
{fields}
return bus;
}}
"""
PROTO_TO_BUS_C = """
// AUTOGENERATED FILE, DO NOT EDIT //
#include "{proto_to_bus_h}"

{impls}
"""


def generate_proto_to_bus_c(mat_structure, proto_to_bus_h):
    impls = []
    for bus_name, bus in mat_structure.items():
        fields = []
        for i, (field_name, type_) in enumerate(bus.items()):
            proto_field_name = get_proto_field_name(field_name)
            if type_ in mat_structure:
                fields.append(
                    PROTO_TO_BUS_CONVERT.format(
                        field_name=field_name,
                        proto_field_name=proto_field_name,
                    )
                )
            else:
                fields.append(
                    PROTO_TO_BUS_ANY.format(
                        field_name=field_name, proto_field_name=proto_field_name
                    )
                )
        impls.append(
            PROTO_TO_BUS_IMPL.format(
                bus_name=bus_name,
                fields="".join(fields),
            )
        )
    return PROTO_TO_BUS_C.format(proto_to_bus_h=proto_to_bus_h, impls="".join(impls))
